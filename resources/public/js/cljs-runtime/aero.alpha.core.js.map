{"version":3,"sources":["aero/alpha/core.cljc"],"mappings":"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","names":["var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","aero.alpha.core/queue","seq28170","self__4724__auto__","cljs.core/seq","xs","cljs.core.into","cljs.core/PersistentQueue","aero.alpha.core/qu","coll","cljs.core.apply","aero.alpha.core/reassemble","this","queue","fexpr__28180","cljs.core.get","cljs.core/meta","aero.alpha.core/kv-seq","x","cljs.core/map?","cljs.core/record?","cljs.core/with-meta","_","cljs.core/empty","cljs.core/set?","cljs.core.map_indexed","idx","v","cljs.core.map","cljs.core/second","cljs.core/vector?","cljs.core.mapv","cljs.core.sort_by","cljs.core/first","cljs.core/seq?","cljs.core/list","js/aero","js/aero.alpha","js/aero.alpha.core","js/aero.alpha.core.eval-tagged-literal","method-table__4619__auto__","cljs.core.atom","prefer-table__4620__auto__","method-cache__4621__auto__","cached-hierarchy__4622__auto__","hierarchy__4623__auto__","fexpr__28181","cljs.core/MultiFn","cljs.core.symbol","aero.alpha.core/eval-tagged-literal","tagged-literal","opts","env","ks","aero.alpha.core/expand-scalar","cljs.core/tagged-literal?","cljs.core.conj","cljs.core.assoc","aero.alpha.core/*max-skips*","aero.alpha.core/expand-coll","steps","q","ss","skip-count","skipped","temp__5733__auto__","vec__28198","cljs.core.nth","k","item","cljs.core/peek","map__28201","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","map__28202","k-incomplete?","k-expansion","G__28203","G__28204","G__28205","G__28206","aero.alpha.core/expand","value","incomplete?","expansion","G__28208","G__28209","G__28210","G__28211","or__4126__auto__","cljs.core/pop","cljs.core.update","cljs.core.fnil","cljs.core/inc","p1__28182#","cljs.core/some","cljs.core/vals","aero.alpha.core/expand-scalar-repeatedly","cljs.core/not","aero.alpha.core/expand-keys","m","cljs.core/keys","map__28217","cljs.core.dissoc","cljs.core/rest","aero.alpha.core/expand-set-keys","cljs.core/reduce-kv","p1__28219#","p2__28220#","cljs.core.reduce","aero.alpha.core/rewrap","tl","cljs.core/tagged-literal","aero.alpha.core/expand-case","case-value","map__28221","map__28222","m-incomplete?","m-expansion","ks-incomplete?","ks-expansion","set-keys-expanded"],"sourcesContent":["(ns aero.alpha.core)\n\n;; Queue utilities\n(defn- queue\n  [& xs]\n  (into #?(:clj (clojure.lang.PersistentQueue/EMPTY)\n           :cljs cljs.core/PersistentQueue.EMPTY)\n        xs))\n\n(defn- qu\n  [coll]\n  (apply queue coll))\n\n(defn reassemble\n  [this queue]\n  ((get (meta this) `reassemble) this queue))\n\n(defn kv-seq\n  \"Implementation detail.  DO NOT USE.  Will be private once out of alpha.\"\n  [x]\n  (cond\n    (and (map? x) (not (record? x)))\n    (with-meta\n      (into [] x)\n      {`reassemble (fn [_ queue] (into (empty x) queue))})\n\n    (set? x)\n    (with-meta (map-indexed (fn [idx v] [idx v]) x)\n               {`reassemble (fn [_ queue]\n                              (into (empty x)\n                                    (map second queue)))})\n\n    (vector? x)\n    (with-meta (map-indexed (fn [idx v] [idx v]) x)\n               {`reassemble (fn [_ queue]\n                              (into (empty x)\n                                    (mapv second (sort-by first queue))))})\n\n    (seq? x)\n    (with-meta (map-indexed (fn [idx v] [idx v]) x)\n               {`reassemble (fn [_ queue]\n                              (with-meta\n                                (apply list (map second (sort-by first queue)))\n                                (meta x)))})\n    ;; Scalar value\n    :else\n    nil))\n\n;; Expansion code\n(defmulti eval-tagged-literal\n  \"Dispatches a tagged literal with control over eval.  Dispatch happens on the\n  :tag of the tagged-literal. opts are the options passed to\n  aero.core/read-config. env is a map of already resolved parts of the config.\n  ks is a vector of keys which make up the current position of the tagged\n  literal.\"\n  (fn [tagged-literal opts env ks] (:tag tagged-literal)))\n\n;; An expansion returns a map containing:\n;; incomplete? - Indicating whether the evaluation completed or not\n;; env - The new value of the environment bindings if appropriate\n;; value - The new value for this expansion (may be a tagged-literal which needs to be requeued, or a complete value)\n(declare expand)\n(declare expand-coll)\n(declare expand-scalar)\n\n(defn expand-scalar\n  \"Expand value x without expanding any elements it may have.  Takes either a scalar or a collection (which will be treated as a scalar).\"\n  [x opts env ks]\n  (if (tagged-literal? x)\n    (eval-tagged-literal x opts env (conj ks :form))\n    {:aero.core/value x\n     :aero.core/env (assoc env ks x)}))\n\n(def ^:private ^:dynamic *max-skips* 1)\n\n(defn expand-coll\n  \"Expand value x as a collection. Does not work with non-collection values.\"\n  [x opts env ks]\n  (let [steps (kv-seq x)]\n    (loop [q (qu steps)\n           ss []\n           env env\n           skip-count {}\n           skipped #{}]\n      (if-let [[k v :as item] (peek q)]\n        (let [{; Ignore env from k expansion because values from k are not\n               ; stored in env.  This decision may need to be revised in the\n               ; future if funky keys such as those which can alter alternative\n               ; parts of the map are wanted.\n\n               ;env :aero.core/env\n               k :aero.core/value\n               k-incomplete? :aero.core/incomplete?\n               env :aero.core/env\n               :or {env env}\n               :as k-expansion}\n              (expand k opts env (conj ks k :aero.core/k))\n\n              {:keys [aero.core/env aero.core/value aero.core/incomplete?]\n               :or {env env}\n               :as expansion}\n              (when-not k-incomplete?\n                (expand v opts env (conj ks k)))]\n          (if (or k-incomplete? incomplete?)\n            (if (<= *max-skips* (get skip-count item 0))\n              (recur (pop q)\n                     (conj ss [k value])\n                     env\n                     (update skip-count item (fnil inc 0))\n                     (conj skipped (if k-incomplete?\n                                     k-expansion\n                                     expansion)))\n              (recur (conj (pop q) [k value])\n                     ss\n                     env\n                     (update skip-count item (fnil inc 0))\n                     skipped))\n            (recur (pop q)\n                   (conj ss [k value])\n                   (assoc env (conj ks k) value)\n                   skip-count\n                   skipped)))\n\n        {:aero.core/value (reassemble steps ss)\n         :aero.core/env env\n         :aero.core/incomplete? (some #(>= % *max-skips*) (vals skip-count))\n         :aero.core/incomplete (some :aero.core/incomplete skipped)\n         ;; Not used anywhere, but useful for debugging\n         :aero.core/_ss ss}))))\n\n(defn expand\n  \"Expand value x.  Dispatches on whether it's a scalar or collection.  If it's\n  a collection it will expand the elements of the collection.\"\n  [x opts env ks]\n  (if (or (and (map? x) (not (record? x))) (set? x) (seq? x) (vector? x))\n    (expand-coll x opts env ks)\n    (expand-scalar x opts env ks)))\n\n(defn expand-scalar-repeatedly\n  \"Expand value x until it is either incomplete or no longer a tagged-literal.\n  Use this to support chained tagged literals, e.g. #or #profile {:dev [1 2]\n                                                                  :prod [2 3]}\"\n  [x opts env ks]\n  (loop [x x]\n    (let [x (expand-scalar x opts env ks)]\n      (if (and (tagged-literal? (:aero.core/value x))\n               (not (:aero.core/incomplete? x)))\n        (recur (:aero.core/value x))\n        x))))\n\n(defn- expand-keys\n  [m opts env ks]\n  (loop [ks (keys m)\n         m m]\n    ;; Can't use k here as `false` and `nil` are valid ks\n    (if (seq ks)\n      (let [{:keys [:aero.core/incomplete? :aero.core/value] :as expansion}\n            (expand (first ks) opts env ks)]\n        (if incomplete?\n          (assoc expansion\n                 :aero.core/value\n                 (-> m\n                     ;; Dissoc first, as k may be unchanged\n                     (dissoc (first ks))\n                     (assoc value (get m (first ks)))))\n          (recur (rest ks)\n                 (-> m\n                     ;; Dissoc first, as k may be unchanged\n                     (dissoc (first ks))\n                     (assoc value (get m (first ks)))))))\n      {:aero.core/value m})))\n\n(defn- expand-set-keys [m]\n  (reduce-kv\n    (fn [m k v]\n      (if (set? k)\n        (reduce #(assoc %1 %2 v) m k)\n        (assoc m k v))) {} m))\n\n(defn- rewrap\n  [tl]\n  (fn [v]\n    (tagged-literal (:tag tl) v)))\n\n(defn expand-case\n  \"Expands a case-like value, in the same way as #profile, #user, etc.\n  \n  case-value is the value to dispatch on, e.g. the result of\n  (System/getenv \\\"USER\\\") for #user.\n\n  tl is the tagged-literal where the :value is a map to do the casing on.\n\n  See implementation of #profile for an example of using this function from\n  eval-tagged-literal.\"\n  [case-value tl opts env ks]\n  (let [{m-incomplete? :aero.core/incomplete?\n         m :aero.core/value\n         :as m-expansion}\n        (expand-scalar-repeatedly (:form tl) opts env ks)\n        \n        {ks-incomplete? :aero.core/incomplete?\n         :keys [:aero.core/value] :as ks-expansion}\n        (when-not m-incomplete?\n          (expand-keys m opts env ks))]\n    (if (or m-incomplete? ks-incomplete?)\n      (update (or m-expansion ks-expansion) :aero.core/value (rewrap tl))\n      (let [set-keys-expanded (expand-set-keys value)]\n        (expand (get set-keys-expanded case-value\n                     (get set-keys-expanded :default))\n                opts env ks)))))\n"]}