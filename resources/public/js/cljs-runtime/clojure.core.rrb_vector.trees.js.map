{"version":3,"sources":["clojure/core/rrb_vector/trees.cljs"],"mappings":"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","names":["clojure.core.rrb-vector.trees/new-path","tail","edit","shift","current-node","s","n","arr","ret","cljs.core/->VectorNode","rngs","clojure.core.rrb-vector.trees/push-tail","cnt","root-edit","tail-node","clojure.core.rrb-vector.nodes/regular?","cljs.core/aclone","subidx","temp__5733__auto__","child","new-carr","new-child","clojure.core.rrb-vector.nodes/node-ranges","li","cret","ccnt","clojure.core.rrb-vector.nodes/overflow?","G__31673","G__31674","G__31675","G__31676","G__31677","msg","data","cljs.core.ex_info","clojure.core.rrb-vector.trees/pop-tail","G__31678","G__31679","G__31680","G__31681","new-rngs","child-cnt","G__31682","G__31683","G__31684","G__31685","rng","clojure.core.rrb-vector.nodes/last-range","diff","clojure.core.rrb-vector.trees/do-assoc","i","val","node","clojure.core.rrb-vector.nodes/clone","G__31686","G__31687","G__31688","G__31689"],"sourcesContent":["(ns clojure.core.rrb-vector.trees\n  (:refer-clojure :exclude [array-for push-tail pop-tail new-path do-assoc])\n  (:require [clojure.core.rrb-vector.nodes\n             :refer [regular? clone node-ranges last-range overflow?]]))\n\n(defn new-path [tail edit shift current-node]\n  (if (== (alength tail) 32)\n    (loop [s 0 n current-node]\n      (if (== s shift)\n        n\n        (let [arr (make-array 32)\n              ret (->VectorNode edit arr)]\n          (aset arr 0 n)\n          (recur (+ s 5) ret))))\n    (loop [s 0 n current-node]\n      (if (== s shift)\n        n\n        (let [arr  (make-array 33)\n              rngs (make-array 33)\n              ret  (->VectorNode edit arr)]\n          (aset arr 0 n)\n          (aset arr 32 rngs)\n          (aset rngs 32 1)\n          (aset rngs 0 (alength tail))\n          (recur (+ s 5) ret))))))\n\n(defn push-tail [shift cnt root-edit current-node tail-node]\n  (if (regular? current-node)\n    (let [arr (aclone (.-arr current-node))\n          ret (->VectorNode (.-edit current-node) arr)]\n      (loop [n ret shift shift]\n        (let [arr    (.-arr n)\n              subidx (bit-and (bit-shift-right (dec cnt) shift) 0x1f)]\n          (if (== shift 5)\n            (aset arr subidx tail-node)\n            (if-let [child (aget arr subidx)]\n              (let [new-carr  (aclone (.-arr child))\n                    new-child (->VectorNode root-edit new-carr)]\n                (aset arr subidx new-child)\n                (recur new-child (- shift 5)))\n              (aset arr subidx\n                    (new-path (.-arr tail-node)\n                              root-edit\n                              (- shift 5)\n                              tail-node))))))\n      ret)\n    (let [arr  (aclone (.-arr current-node))\n          rngs (node-ranges current-node)\n          li   (dec (aget rngs 32))\n          ret  (->VectorNode (.-edit current-node) arr)\n          cret (if (== shift 5)\n                 nil\n                 (let [child (aget arr li)\n                       ccnt  (+ (if (pos? li)\n                                  (- (aget rngs li) (aget rngs (dec li)))\n                                  (aget rngs 0))\n                                ;; add 32 elems to account for the new\n                                ;; 32-elem tail we plan to add to the\n                                ;; subtree.\n                                32)]\n                   ;; See Note 2 in file transients.cljs\n                   (if-not (overflow? child (- shift 5) ccnt)\n                     (push-tail (- shift 5) ccnt root-edit\n                                child\n                                tail-node))))]\n      (if cret\n        (do (aset arr li cret)\n            (aset rngs li (+ (aget rngs li) 32))\n            ret)\n        (do (when (>= li 31)\n              ;; See Note 1 in file transients.cljs\n              (let [msg (str \"Assigning index \" (inc li) \" of vector\"\n                             \" object array to become a node, when that\"\n                             \" index should only be used for storing\"\n                             \" range arrays.\")\n                    data {:shift shift, :cnt cnt, :current-node current-node,\n                          :tail-node tail-node, :rngs rngs, :li li,\n                          :cret cret}]\n                (throw (ex-info msg data))))\n            (aset arr (inc li)\n                  (new-path (.-arr tail-node)\n                            root-edit\n                            (- shift 5)\n                            tail-node))\n            (aset rngs (inc li) (+ (aget rngs li) 32))\n            (aset rngs 32 (inc (aget rngs 32)))\n            ret)))))\n\n(defn pop-tail [shift cnt root-edit current-node]\n  (if (regular? current-node)\n    (let [subidx (bit-and (bit-shift-right (- cnt 2) shift) 0x1f)]\n      (cond\n        (> shift 5)\n        (let [new-child (pop-tail (- shift 5) cnt root-edit\n                                  (aget (.-arr current-node) subidx))]\n          (if (and (nil? new-child) (zero? subidx))\n            nil\n            (let [arr (aclone (.-arr current-node))]\n              (aset arr subidx new-child)\n              (->VectorNode root-edit arr))))\n\n        (zero? subidx)\n        nil\n\n        :else\n        (let [arr (aclone (.-arr current-node))]\n          (aset arr subidx nil)\n          (->VectorNode root-edit arr))))\n    (let [rngs   (node-ranges current-node)\n          subidx (dec (aget rngs 32))\n          new-rngs (aclone rngs)]\n      (cond\n        (> shift 5)\n        (let [child     (aget (.-arr current-node) subidx)\n              child-cnt (if (zero? subidx)\n                          (aget rngs 0)\n                          (- (aget rngs subidx) (aget rngs (dec subidx))))\n              new-child (pop-tail (- shift 5) child-cnt root-edit child)]\n          (cond\n            (and (nil? new-child) (zero? subidx))\n            nil\n\n            (regular? child)\n            (let [arr (aclone (.-arr current-node))]\n              (aset new-rngs subidx (- (aget new-rngs subidx) 32))\n              (aset arr subidx new-child)\n              (aset arr 32 new-rngs)\n              (if (nil? new-child)\n                (aset new-rngs 32 (dec (aget new-rngs 32))))\n              (->VectorNode root-edit arr))\n\n            :else\n            (let [rng  (last-range child)\n                  diff (- rng (if new-child (last-range new-child) 0))\n                  arr  (aclone (.-arr current-node))]\n              (aset new-rngs subidx (- (aget new-rngs subidx) diff))\n              (aset arr subidx new-child)\n              (aset arr 32 new-rngs)\n              (if (nil? new-child)\n                (aset new-rngs 32 (dec (aget new-rngs 32))))\n              (->VectorNode root-edit arr))))\n\n        (zero? subidx)\n        nil\n\n        :else\n        (let [arr      (aclone (.-arr current-node))\n              child    (aget arr subidx)\n              new-rngs (aclone rngs)]\n          (aset arr subidx nil)\n          (aset arr 32 new-rngs)\n          (aset new-rngs subidx 0)\n          (aset new-rngs 32 (dec (aget new-rngs 32)))\n          (->VectorNode root-edit arr))))))\n\n(defn do-assoc [shift current-node i val]\n  (if (regular? current-node)\n    (let [node (clone shift current-node)]\n      (loop [shift shift\n             node  node]\n        (if (zero? shift)\n          (let [arr (.-arr node)]\n            (aset arr (bit-and i 0x1f) val))\n          (let [arr    (.-arr node)\n                subidx (bit-and (bit-shift-right i shift) 0x1f)\n                child  (clone shift (aget arr subidx))]\n            (aset arr subidx child)\n            (recur (- shift 5) child))))\n      node)\n    (let [arr    (aclone (.-arr current-node))\n          rngs   (node-ranges current-node)\n          subidx (bit-and (bit-shift-right i shift) 0x1f)\n          subidx (loop [subidx subidx]\n                   (if (< i (int (aget rngs subidx)))\n                     subidx\n                     (recur (inc subidx))))\n          i      (if (zero? subidx) i (- i (aget rngs (dec subidx))))]\n      (aset arr subidx\n            (do-assoc (- shift 5) (aget arr subidx) i val))\n      (->VectorNode (.-edit current-node) arr))))\n"]}