{"version":3,"sources":["aero/impl/walk.cljc"],"mappings":";AAEA,AAAA,AAAOA,AACJC,AAAMC,AAAMC;AADf,AAEE,AAAMC,AAAE,AACE,AAACC,AAAMF,AAAM,AAAAG,AAAO,AAACC,AAAMC,AAAK,AAACC,AAAIR,AAAME;AAA9B,AAAA,AAAAG,AAAAA,AAACJ,AAAAA,AAAAA;AADhB,AAEa,AAACQ,AAAWP,AAAM,AAAAQ,AAAO,AAAAC,AAAW,AAAAC,AAAO,AAACC,AAAIX;AAAZ,AAAA,AAAAU,AAAAA,AAACZ,AAAAA,AAAAA;AAAkB,AAAAc,AAAO,AAACC,AAAIb;AAAZ,AAAA,AAAAY,AAAAA,AAACd,AAAAA,AAAAA;AAA/B;AAAP,AAAA,AAAAU,AAAAA,AAACT,AAAAA,AAAAA;AAFhC,AAIE,AAACe,AAAKd,AAAM,AAAAe,AAAO,AAACC,AAAM,AAACV,AAAIR,AAAME;AAAzB,AAAA,AAAAe,AAAAA,AAAChB,AAAAA,AAAAA;AAJf,AAKW,AAACkB,AAAQjB,AAElB,AAAAkB,AAAO,AAACC,AAAO,AAAKC,AAAEnB;AAAP,AAAU,AAACoB,AAAKD,AAAE,AAACtB,AAAAA,AAAAA,AAAMG,AAAAA;AAAKD,AAAKA;AAAlD,AAAA,AAAAkB,AAAAA,AAACnB,AAAAA,AAAAA;AAPH,AAQE,AAACuB,AAAMtB,AAAM,AAAAuB,AAAO,AAACC,AAAK,AAACC,AAAMzB,AAAM,AAACM,AAAIR,AAAME;AAArC,AAAA,AAAAuB,AAAAA,AAACxB,AAAAA,AAAAA;AARhB,AASQ,AAACA,AAAAA,AAAAA,AAAMC,AAAAA;;AATvB,AAUE,AAAa,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA0B,AAAA,AAAA,AAAA,AAAA,AAAuBzB,AAAAA,AAAAA;AAElC,AAAC0B,AAAU1B,AAAE,AAAC2B,AAAM,AAACC,AAAK7B,AAAM,AAAC6B,AAAK5B;;AACtCA;;;AAEN,AAAA,AAAM6B,AACHC,AAAE/B;AADL,AAEE,AAACH,AAAK,AAACmC,AAAQF,AAASC,AAAGA,AAAE/B","names":["aero.impl.walk/walk","inner","outer","form","x","cljs.core/list?","G__28256","cljs.core.apply","cljs.core/list","cljs.core.map","cljs.core/map-entry?","G__28257","cljs.core/MapEntry","G__28258","cljs.core/key","G__28259","cljs.core/val","cljs.core/seq?","G__28260","cljs.core.doall","cljs.core/record?","G__28261","cljs.core.reduce","r","cljs.core.conj","cljs.core/coll?","G__28262","cljs.core.into","cljs.core/empty","cljs.core/PROTOCOL_SENTINEL","cljs.core/with-meta","cljs.core.merge","cljs.core/meta","aero.impl.walk/postwalk","f","cljs.core.partial"],"sourcesContent":["(ns aero.impl.walk)\n\n(defn- walk\n  [inner outer form]\n  (let [x (cond\n            (list? form) (outer (apply list (map inner form)))\n            #?@(:cljs [(map-entry? form) (outer (MapEntry. (inner (key form)) (inner (val form)) nil))]\n                :clj [(instance? clojure.lang.IMapEntry form) (outer (vec (map inner form)))])\n            (seq? form) (outer (doall (map inner form)))\n            #?(:cljs (record? form)\n               :clj (instance? clojure.lang.IRecord form))\n            (outer (reduce (fn [r x] (conj r (inner x))) form form))\n            (coll? form) (outer (into (empty form) (map inner form)))\n            :else (outer form))]\n    (if #?(:cljs (implements? IWithMeta x)\n           :clj (instance? clojure.lang.IObj x))\n      (with-meta x (merge (meta form) (meta x)))\n      x)))\n\n(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))\n"]}