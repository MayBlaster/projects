{"version":3,"sources":["clojure/core/rrb_vector/transients.cljs"],"mappings":"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","names":["clojure.core.rrb-vector.transients/ensure-editable","edit","node","new-arr","cljs.core/aclone","cljs.core/VectorNode","clojure.core.rrb-vector.transients/editable-root","root","clojure.core.rrb-vector.transients/editable-tail","tail","ret","cljs.core/array-copy","clojure.core.rrb-vector.transients/push-tail!","shift","cnt","root-edit","current-node","tail-node","clojure.core.rrb-vector.nodes/regular?","n","arr","subidx","child","clojure.core.rrb-vector.trees/new-path","editable-child","rngs","clojure.core.rrb-vector.nodes/node-ranges","li","cret","ccnt","clojure.core.rrb-vector.nodes/overflow?","G__31717","G__31718","G__31719","G__31720","G__31721","msg","data","cljs.core.ex_info","clojure.core.rrb-vector.transients/pop-tail!","G__31722","G__31723","G__31724","G__31725","child-cnt","new-child","G__31726","G__31727","G__31728","G__31729","rng","clojure.core.rrb-vector.nodes/last-range","diff","clojure.core.rrb-vector.transients/do-assoc!","i","val","G__31730","G__31731","G__31732","G__31733","G__31734"],"sourcesContent":["(ns clojure.core.rrb-vector.transients\n  (:refer-clojure :exclude [new-path])\n  (:require [clojure.core.rrb-vector.nodes\n             :refer [regular? clone node-ranges last-range overflow?]]\n            [clojure.core.rrb-vector.trees :refer [new-path]]))\n\n(defn ensure-editable [edit node]\n  (if (identical? (.-edit node) edit)\n    node\n    (let [new-arr (aclone (.-arr node))]\n      (if (== 33 (alength new-arr))\n        (aset new-arr 32 (aclone (aget new-arr 32))))\n      (VectorNode. edit new-arr))))\n\n(defn editable-root [root]\n  (let [new-arr (aclone (.-arr root))]\n    (if (== 33 (alength new-arr))\n      (aset new-arr 32 (aclone (aget new-arr 32))))\n    (VectorNode. (js-obj) new-arr)))\n\n(defn editable-tail [tail]\n  (let [ret (make-array 32)]\n    (array-copy tail 0 ret 0 (alength tail))\n    ret))\n\n;; Note 1: This condition check and exception are a little bit closer\n;; to the source of the cause for what was issue CRRBV-20, added in\n;; case there is still some remaining way to cause this condition to\n;; occur.\n\n;; Note 2: In the worst case, when the tree is nearly full, calling\n;; overflow? here takes run time O(tree_depth^2) here.  That could be\n;; made O(tree_depth).  One way would be to call push-tail! in hopes\n;; that it succeeds, but return some distinctive value indicating a\n;; failure on the full condition, and create the node via a new-path\n;; call at most recent recursive push-tail! call that has an empty\n;; slot available.\n(defn push-tail! [shift cnt root-edit current-node tail-node]\n  (let [ret (ensure-editable root-edit current-node)]\n    (if (regular? ret)\n      (do (loop [n ret shift shift]\n            (let [arr    (.-arr n)\n                  subidx (bit-and (bit-shift-right (dec cnt) shift) 0x1f)]\n              (if (== shift 5)\n                (aset arr subidx tail-node)\n                (let [child (aget arr subidx)]\n                  (if (nil? child)\n                    (aset arr subidx\n                          (new-path (.-arr tail-node)\n                                    root-edit\n                                    (- shift 5)\n                                    tail-node))\n                    (let [editable-child (ensure-editable root-edit child)]\n                      (aset arr subidx editable-child)\n                      (recur editable-child (- shift 5))))))))\n          ret)\n      (let [arr  (.-arr ret)\n            rngs (node-ranges ret)\n            li   (dec (aget rngs 32))\n            cret (if (== shift 5)\n                   nil\n                   (let [child (ensure-editable root-edit (aget arr li))\n                         ccnt  (+ (if (pos? li)\n                                    (- (aget rngs li) (aget rngs (dec li)))\n                                    (aget rngs 0))\n                                  ;; add 32 elems to account for the\n                                  ;; new full tail we plan to add to\n                                  ;; the subtree.\n                                  32)]\n                     ;; See Note 2\n                     (if-not (overflow? child (- shift 5) ccnt)\n                       (push-tail! (- shift 5) ccnt root-edit\n                                   child\n                                   tail-node))))]\n        (if cret\n          (do (aset arr  li cret)\n              (aset rngs li (+ (aget rngs li) 32))\n              ret)\n          (do (when (>= li 31)\n                ;; See Note 1\n                (let [msg (str \"Assigning index \" (inc li) \" of vector\"\n                               \" object array to become a node, when that\"\n                               \" index should only be used for storing\"\n                               \" range arrays.\")\n                      data {:shift shift, :cnd cnt,\n                            :current-node current-node,\n                            :tail-node tail-node, :rngs rngs, :li li,\n                            :cret cret}]\n                  (throw (ex-info msg data))))\n              (aset arr (inc li)\n                    (new-path (.-arr tail-node)\n                              root-edit\n                              (- shift 5)\n                              tail-node))\n              (aset rngs (inc li) (+ (aget rngs li) 32))\n              (aset rngs 32 (inc (aget rngs 32)))\n              ret))))))\n\n(defn pop-tail! [shift cnt root-edit current-node]\n  (let [ret (ensure-editable root-edit current-node)]\n    (if (regular? ret)\n      (let [subidx (bit-and (bit-shift-right (- cnt 2) shift) 0x1f)]\n        (cond\n          (> shift 5)\n          (let [child (pop-tail! (- shift 5) cnt root-edit\n                                 (aget (.-arr ret) subidx))]\n            (if (and (nil? child) (zero? subidx))\n              nil\n              (let [arr (.-arr ret)]\n                (aset arr subidx child)\n                ret)))\n\n          (zero? subidx)\n          nil\n\n          :else\n          (let [arr (.-arr ret)]\n            (aset arr subidx nil)\n            ret)))\n      (let [rngs   (node-ranges ret)\n            subidx (dec (aget rngs 32))]\n        (cond\n          (> shift 5)\n          (let [child     (aget (.-arr ret) subidx)\n                child-cnt (if (zero? subidx)\n                            (aget rngs 0)\n                            (- (aget rngs subidx) (aget rngs (dec subidx))))\n                new-child (pop-tail! (- shift 5) child-cnt root-edit child)]\n            (cond\n              (and (nil? new-child) (zero? subidx))\n              nil\n\n              (regular? child)\n              (let [arr (.-arr ret)]\n                (aset rngs subidx (- (aget rngs subidx) 32))\n                (aset arr  subidx new-child)\n                (if (nil? new-child)\n                  (aset rngs 32 (dec (aget rngs 32))))\n                ret)\n\n              :else\n              (let [rng  (last-range child)\n                    diff (- rng (if new-child (last-range new-child) 0))\n                    arr  (.-arr ret)]\n                (aset rngs subidx (- (aget rngs subidx) diff))\n                (aset arr  subidx new-child)\n                (if (nil? new-child)\n                  (aset rngs 32 (dec (aget rngs 32))))\n                ret)))\n\n          (zero? subidx)\n          nil\n\n          :else\n          (let [arr   (.-arr ret)\n                child (aget arr subidx)]\n            (aset arr  subidx nil)\n            (aset rngs subidx 0)\n            (aset rngs 32     (dec (aget rngs 32)))\n            ret))))))\n\n(defn do-assoc! [shift root-edit current-node i val]\n  (let [ret (ensure-editable root-edit current-node)]\n    (if (regular? ret)\n      (loop [shift shift\n             node  ret]\n        (if (zero? shift)\n          (let [arr (.-arr node)]\n            (aset arr (bit-and i 0x1f) val))\n          (let [arr    (.-arr node)\n                subidx (bit-and (bit-shift-right i shift) 0x1f)\n                child  (ensure-editable root-edit (aget arr subidx))]\n            (aset arr subidx child)\n            (recur (- shift 5) child))))\n      (let [arr    (.-arr ret)\n            rngs   (node-ranges ret)\n            subidx (bit-and (bit-shift-right i shift) 0x1f)\n            subidx (loop [subidx subidx]\n                     (if (< i (int (aget rngs subidx)))\n                       subidx\n                       (recur (inc subidx))))\n            i      (if (zero? subidx) i (- i (aget rngs (dec subidx))))]\n        (aset arr subidx\n              (do-assoc! (- shift 5) root-edit (aget arr subidx) i val))))\n    ret))\n"]}