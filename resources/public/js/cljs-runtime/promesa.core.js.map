{"version":3,"sources":["promesa/core.cljc"],"mappings":"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","names":["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__28183","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","G__28189","promesa.core/create","f","d","e28190","G__28191","p1__28184#","G__28192","p1__28185#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e28193","G__28194","p1__28186#","G__28195","p1__28187#","promesa.core/promise?","promesa.impl/*default-promise*","promesa.core/deferred?","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","promesa.core/wrap","G__28197","promesa.core/then","promesa.protocols/-then","G__28199","promesa.core/bind","G__28201","promesa.core/then'","G__28203","promesa.core/map","G__28205","promesa.core/mapcat","promesa.protocols/-bind","G__28212","promesa.core/chain","args-arr__4757__auto__","len__4736__auto__","i__4737__auto__","argseq__4758__auto__","cljs.core/IndexedSeq","seq28209","G__28210","cljs.core/first","cljs.core/next","G__28211","self__4723__auto__","promesa.core.then","fs","p1__28206#","p2__28207#","cljs.core.reduce","cljs.core/cons","G__28217","promesa.core/chain'","seq28214","G__28215","G__28216","promesa.core.then_SINGLEQUOTE_","G__28219","promesa.core/handle","promesa.protocols/-handle","G__28221","promesa.core/finally","promesa.protocols/-finally","G__28224","promesa.core/catch","promesa.protocols/-thenErr","pred-or-type","accept?","p1__28222#","cljs.core/ifn?","G__28227","promesa.core/catch'","promesa.protocols/-mapErr","p1__28225#","G__28229","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__28231","promesa.core/any","promesa.core.any","default","state","cljs.core.atom","cljs.core/count","promesa.core.create","resolve","reject","seq__28232","cljs.core/seq","chunk__28233","count__28234","i__28235","temp__5735__auto__","cljs.core/chunked-seq?","c__4556__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","promesa.core.promise","cljs.core/deref","cljs.core.swap_BANG_","cljs.core.assoc","cljs.core.update","cljs.core/dec","cljs.core/conj","map__28242","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","map__28245","resolved","counter","rejections","cljs.core/not","cljs.core._EQ_","G__28244","G__28247","cljs.core.ex_info","G__28251","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/current-thread-executor","p1__28248#","p2__28249#","_","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__28253","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e28254","promesa.core/TimeoutException","message","it","goog/inherits","G__28256","promesa.core/timeout","t","promesa.core.timeout","promesa.exec/default-scheduler","scheduler","timeout","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","G__28258","promesa.core/delay","promesa.core.delay","promesa.core/*loop-run-fn*","promesa.exec/run!"],"sourcesContent":[";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.TimeoutException)))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v] (pt/-promise v))\n  ([v executor]\n   (pt/-map v identity executor)))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Exception :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn wrap\n  [v]\n  (if (promise? v)\n    v\n    (pt/-promise v)))\n\n(defn then\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.\"\n  ([p f]\n   (pt/-then p f))\n  ([p f executor]\n   (pt/-then p f executor)))\n\n(defn bind\n  \"A convenient alias for `then`.\"\n  ([p f]\n   (pt/-then p f))\n  ([p f executor]\n   (pt/-then p f executor)))\n\n(defn then'\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.\"\n  ([p f] (pt/-map p f))\n  ([p f executor] (pt/-map p f executor)))\n\n(defn map\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.\"\n  ([f p] (pt/-map p f))\n  ([executor f p] (pt/-map p f executor)))\n\n(defn mapcat\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.\"\n  ([f p] (pt/-bind p f))\n  ([executor f p] (pt/-bind p f executor)))\n\n(defn chain\n  \"Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce #(then %1 %2) p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce pt/-map p (cons f fs))))\n\n(defn handle\n  \"Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.\"\n  ([p f] (pt/-handle p f))\n  ([p f executor] (pt/-handle p f executor)))\n\n(defn finally\n  \"Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.\"\n  ([p f] (pt/-finally p f))\n  ([p f executor] (pt/-finally p f executor)))\n\n(defn catch\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-thenErr p f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-thenErr p (fn [e]\n                      (if (accept? e)\n                        (f e)\n                        (impl/rejected e)))))))\n\n(defn catch'\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-mapErr p f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-mapErr p (fn [e]\n                     (if (accept? e)\n                        (f e)\n                        (throw e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (-> (.all impl/*default-promise* (into-array promises))\n               (then' vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (then' (->> (into-array CompletableFuture promises)\n                        (CompletableFuture/allOf))\n                   (fn [_]\n                     (mapv pt/-extract promises))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (cljs.core/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (->> (clojure.core/map pt/-promise promises)\n                                        (into-array CompletableFuture)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [state (atom {:resolved false\n                      :counter (count promises)\n                      :rejections []})]\n     (create\n      (fn [resolve reject]\n        (doseq [p promises]\n          (-> (promise p)\n              (then (fn [v]\n                      (when-not (:resolved @state)\n                        (swap! state (fn [state]\n                                       (-> state\n                                           (assoc :resolved true)\n                                           (update :counter dec))))\n                        (resolve v))))\n              (catch (fn [e]\n                       (swap! state (fn [state]\n                                      (-> state\n                                          (update  :counter dec)\n                                          (update :rejections conj e))))\n                       (c/let [{:keys [resolved counter rejections]} @state]\n                         (when (and (not resolved) (= counter 0))\n                           (if (= default ::default)\n                             (reject (ex-info \"No promises resolved\"\n                                              {:rejections rejections}))\n                             (resolve default)))))))))))))\n\n(defn run!\n  \"A promise aware run! function.\"\n  ([f coll] (run! f coll exec/current-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError\"\n  ([p t] (timeout p t ::default exec/default-scheduler))\n  ([p t v] (timeout p t v exec/default-scheduler))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)]\n     (exec/schedule! scheduler t #(if (= v ::default)\n                                    (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                    (resolve! timeout v)))\n     (race [p timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached.\"\n  ([t] (delay t nil exec/default-scheduler))\n  ([t v] (delay t v exec/default-scheduler))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n(defmacro do!\n  \"Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression.\"\n  [& exprs]\n  `(pt/-bind nil (fn [_#]\n                   ~(condp = (count exprs)\n                      0 `(pt/-promise nil)\n                      1 `(pt/-promise ~(first exprs))\n                      (reduce (fn [acc e]\n                                `(pt/-bind ~e (fn [_#] ~acc)))\n                              `(pt/-promise ~(last exprs))\n                              (reverse (butlast exprs)))))))\n\n(defmacro let\n  \"A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.\"\n  [bindings & body]\n  `(pt/-bind nil (fn [_#]\n                   ~(->> (reverse (partition 2 bindings))\n                         (reduce (fn [acc [l r]]\n                                   `(pt/-bind ~r (fn [~l] ~acc)))\n                                 `(do! ~@body))))))\n\n(defmacro plet\n  \"A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.\"\n  [bindings & body]\n  `(pt/-bind nil (fn [_#]\n                   ~(c/let [bindings (partition 2 bindings)]\n                      `(-> (all ~(mapv second bindings))\n                           (then (fn [[~@(mapv first bindings)]]\n                                   (do! ~@body))))))))\n\n(defmacro future\n  \"Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs).\"\n  [& body]\n  `(-> (exec/submit! (fn []\n                       (c/let [f# (fn [] ~@body)]\n                         (pt/-promise (f#)))))\n       (pt/-bind identity)))\n\n(def ^:dynamic *loop-run-fn* exec/run!)\n\n(defmacro loop\n  [bindings & body]\n  (c/let [bindings (partition 2 2 bindings)\n          names (mapv first bindings)\n          fvals (mapv second bindings)\n          tsym (gensym \"loop\")\n          dsym (gensym \"deferred\")\n          rsym (gensym \"run\")]\n    `(c/let [~rsym *loop-run-fn*\n             ~dsym (promesa.core/deferred)\n             ~tsym (fn ~tsym [params#]\n                     (-> (promesa.core/all params#)\n                         (promesa.core/then (fn [[~@names]]\n                                              ;; (prn \"exec\" ~@names)\n                                              (do! ~@body)))\n                         (promesa.core/handle\n                          (fn [res# err#]\n                            ;; (prn \"result\" res# err#)\n                            (cond\n                              (not (nil? err#))\n                              (promesa.core/reject! ~dsym err#)\n\n                              (and (map? res#) (= (:type res#) :promesa.core/recur))\n                              (do (~rsym (fn [] (~tsym (:args res#))))\n                                  nil)\n\n                              :else\n                              (promesa.core/resolve! ~dsym res#))))))]\n       (~rsym (fn [] (~tsym ~fvals)))\n       ~dsym)))\n\n(defmacro recur\n  [& args]\n  `(array-map :type :promesa.core/recur :args [~@args]))\n"]}