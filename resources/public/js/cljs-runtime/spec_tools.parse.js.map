{"version":3,"sources":["spec_tools/parse.cljc"],"mappings":"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","names":["spec-tools.parse/type-dispatch-value","type","fexpr__29992","cljs.core/sequential?","cljs.core/first","cljs.core/identity","spec-tools.parse/collection-type?","cljs.core/contains?","spec-tools.parse/leaf-type?","spec-tools.parse/non-leaf-types","var_args","G__29994","spec-tools.parse/parse-spec","js/Error","x","spec_tools.parse.parse_spec","options","cljs.core._EQ_","cljs.core/qualified-keyword?","cljs.core.get","cljs.spec.alpha/form","cljs.spec.alpha/get-spec","cljs.core.update","cljs.core.fnil","cljs.core/conj","cljs.core/Symbol","G__29995","G__29996","G__29997","spec-tools.parse/parse-form","spec-tools.impl/normalize-symbol","cljs.core/seq?","G__29998","G__29999","G__30000","cljs.spec.alpha/spec?","cljs.core/ifn?","G__30001","G__30002","G__30003","spec-tools.form/resolve-form","spec-tools.parse/parse-spec-with-spec-ref","cljs.core.merge","spec-tools.parse/get-keys","parse-data","or__4126__auto__","G__30004","cljs.core.keep","cljs.core.apply","cljs.core/concat","cljs.core/seq","cljs.core/set","js/spec-tools","js/spec-tools.parse","js/spec-tools.parse.parse-form","method-table__4619__auto__","cljs.core.atom","prefer-table__4620__auto__","method-cache__4621__auto__","cached-hierarchy__4622__auto__","hierarchy__4623__auto__","fexpr__30005","cljs.core/MultiFn","cljs.core.symbol","dispatch","_","spec-tools.parse/types","spec-tools.parse/type-symbols","cljs.core/methods","cljs.core/keys","cljs.core.filter","cljs.core/symbol?","cljs.core/any?","cljs.core/some?","cljs.core/number?","cljs.core/integer?","cljs.core/int?","cljs.core/pos-int?","cljs.core/neg-int?","cljs.core/nat-int?","cljs.core/float?","cljs.core/double?","cljs.core/boolean?","cljs.core/string?","cljs.core/ident?","cljs.core/simple-ident?","cljs.core/qualified-ident?","cljs.core/keyword?","cljs.core/simple-keyword?","cljs.core/simple-symbol?","cljs.core/qualified-symbol?","cljs.core/uuid?","cljs.core/inst?","cljs.core/seqable?","cljs.core/indexed?","cljs.core/map?","cljs.core/vector?","cljs.core/list?","cljs.core/char?","cljs.core/set?","cljs.core/nil?","cljs.core/false?","cljs.core/true?","cljs.core/zero?","cljs.core/coll?","cljs.core/empty?","cljs.core/associative?","form","map__30009","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","req","opt","req-un","opt-un","key->spec","spec-tools.impl/parse-keys","G__30011","cljs.core.concat","cljs.core.assoc","spec-tools.parse/get-multi-spec-sub-specs","multi-spec-form","vec__30012","seq__30013","first__30014","cljs.core/next","multi-method-symbol","temp__5735__auto__","spec","v","cljs.core/vals","cljs.spec.alpha/registry","cljs.core/deref","cljs.core.map","p__30015","vec__30016","cljs.core.nth","spec-k","method","cljs.core/last","cljs.core.into","specs","cljs.core.mapv","p1__30019#","cljs.core.comp","cljs.core/second","cljs.core.partition","cljs.core/rest","cljs.core.distinct","cljs.core/vec","p1__30020#","types","p1__30021#","type-priority","spec-tools.impl/deep-merge","p1__30022#","cljs.core.sort_by","map__30023","into","cljs.core.drop","map__30025","p__30027","vec__30028","k","parsed","p__30032","vec__30033","seq__30034","first__30035","values","p1__30031#","p1__30036#","G__30039","fexpr__30038","p1__30037#"],"sourcesContent":["(ns spec-tools.parse\n  (:require [spec-tools.impl :as impl]\n            [clojure.spec.alpha :as s]\n            [spec-tools.form :as form]))\n\n(declare parse-form)\n(declare non-leaf-types)\n\n(defn type-dispatch-value [type]\n  ((if (sequential? type) first identity) type))\n\n(defn collection-type? [type]\n  (contains? #{:map :map-of :set :vector :tuple} type))\n\n(defn leaf-type? [type]\n  (not (contains? (non-leaf-types) type)))\n\n(defn parse-spec\n  \"Parses info out of a spec. Spec can be passed as a name, Spec or a form.\n  Returns either `nil` or a map, with keys `:type` and other extra keys\n  (like `:keys` for s/keys specs).\"\n  ([x]\n   (parse-spec x nil))\n  ([x options]\n   (cond\n\n     ;; unknown\n     (= ::s/unknown x)\n     nil\n\n     ;; spec name - handle in the two arity version to account for recursive calls\n     (qualified-keyword? x)\n     (if (get (::visited options) x)\n       {:spec x}\n       (parse-spec (s/form (s/get-spec x)) (update options ::visited (fnil conj #{}) x)))\n     \n     ;; symbol\n     (symbol? x)\n     (parse-form (impl/normalize-symbol x) nil options)\n\n     ;; a form\n     (seq? x)\n     (parse-form (impl/normalize-symbol (first x)) x options)\n\n     ;; a spec\n     (s/spec? x)\n     (recur (s/form x) options)\n\n     ;; a predicate\n     (ifn? x)\n     (parse-form (impl/normalize-symbol (form/resolve-form x)) nil options)\n\n     ;; default\n     :else (parse-form x nil options))))\n\n(defn parse-spec-with-spec-ref [x options]\n  (merge (parse-spec x options) (if (qualified-keyword? x) {:spec x})))\n\n(defn get-keys [parse-data]\n  (or (::keys parse-data)\n      (some->> parse-data ::items (keep get-keys) (apply concat) (seq) (set))))\n\n(defmulti parse-form (fn [dispatch _ _] dispatch) :default ::default)\n\n(defmethod parse-form ::default [_ _ _] {:type nil})\n\n(defn- non-leaf-types []\n  #{:map :map-of :and :or :nilable :tuple :set :vector :multi-spec})\n\n(defn types []\n  #{:long\n    :double\n    :boolean\n    :string\n    :keyword\n    :symbol\n    :uuid\n    :uri\n    :bigdec\n    :date\n    :ratio\n    :map\n    :map-of\n    :multi-spec\n    :and\n    :or\n    :set\n    :tuple\n    :nilable\n    :vector\n    :spec})\n\n(defn type-symbols []\n  (-> parse-form\n      methods\n      keys\n      (->> (filter symbol?))\n      set))\n\n(defmethod parse-form 'clojure.core/any?               [_ _ _] {:spec any?})\n(defmethod parse-form 'clojure.core/some?              [_ _ _] {:spec some?})\n(defmethod parse-form 'clojure.core/number?            [_ _ _] {:spec number?, :type :double})\n(defmethod parse-form 'clojure.core/integer?           [_ _ _] {:spec integer?, :type :long})\n(defmethod parse-form 'clojure.core/int?               [_ _ _] {:spec int?, :type :long})\n(defmethod parse-form 'clojure.core/pos-int?           [_ _ _] {:spec pos-int?, :type :long})\n(defmethod parse-form 'clojure.core/neg-int?           [_ _ _] {:spec neg-int?, :type :long})\n(defmethod parse-form 'clojure.core/nat-int?           [_ _ _] {:spec nat-int?, :type :long})\n(defmethod parse-form 'clojure.core/float?             [_ _ _] {:spec float?, :type :double})\n(defmethod parse-form 'clojure.core/double?            [_ _ _] {:spec double?, :type :double})\n(defmethod parse-form 'clojure.core/boolean?           [_ _ _] {:spec boolean?, :type :boolean})\n(defmethod parse-form 'clojure.core/string?            [_ _ _] {:spec string?, :type :string})\n(defmethod parse-form 'clojure.core/ident?             [_ _ _] {:spec ident? :type :keyword})\n(defmethod parse-form 'clojure.core/simple-ident?      [_ _ _] {:spec simple-ident?, :type :keyword})\n(defmethod parse-form 'clojure.core/qualified-ident?   [_ _ _] {:spec qualified-ident?, :type :keyword})\n(defmethod parse-form 'clojure.core/keyword?           [_ _ _] {:spec keyword?, :type :keyword})\n(defmethod parse-form 'clojure.core/simple-keyword?    [_ _ _] {:spec simple-keyword?, :type :keyword})\n(defmethod parse-form 'clojure.core/qualified-keyword? [_ _ _] {:spec qualified-keyword? :type :keyword})\n(defmethod parse-form 'clojure.core/symbol?            [_ _ _] {:spec symbol?, :type :symbol})\n(defmethod parse-form 'clojure.core/simple-symbol?     [_ _ _] {:spec simple-symbol?, :type :symbol})\n(defmethod parse-form 'clojure.core/qualified-symbol?  [_ _ _] {:spec qualified-symbol?, :type :symbol})\n(defmethod parse-form 'clojure.core/uuid?              [_ _ _] {:spec uuid?, :type :uuid})\n#?(:clj (defmethod parse-form 'clojure.core/uri?       [_ _ _] {:spec uri?, :type :uri}))\n#?(:clj (defmethod parse-form 'clojure.core/decimal?   [_ _ _] {:spec decimal?, :type :bigdec}))\n(defmethod parse-form 'clojure.core/inst?              [_ _ _] {:spec inst?, :type :date})\n(defmethod parse-form 'clojure.core/seqable?           [_ _ _] {:spec seqable?})\n(defmethod parse-form 'clojure.core/indexed?           [_ _ _] {:spec indexed?})\n(defmethod parse-form 'clojure.core/map?               [_ _ _] {:spec map?})\n(defmethod parse-form 'clojure.core/vector?            [_ _ _] {:spec vector?})\n(defmethod parse-form 'clojure.core/list?              [_ _ _] {:spec list?})\n(defmethod parse-form 'clojure.core/seq?               [_ _ _] {:spec seq?})\n(defmethod parse-form 'clojure.core/char?              [_ _ _] {:spec char?})\n(defmethod parse-form 'clojure.core/set?               [_ _ _] {:spec set?})\n(defmethod parse-form 'clojure.core/nil?               [_ _ _] {:spec nil?})\n(defmethod parse-form 'clojure.core/false?             [_ _ _] {:spec false?, :type :boolean})\n(defmethod parse-form 'clojure.core/true?              [_ _ _] {:spec true?, :type :boolean})\n(defmethod parse-form 'clojure.core/zero?              [_ _ _] {:spec zero?, :type :long})\n#?(:clj (defmethod parse-form 'clojure.core/rational?  [_ _ _] {:spec rational?, :type :long}))\n(defmethod parse-form 'clojure.core/coll?              [_ _ _] {:spec coll?})\n(defmethod parse-form 'clojure.core/empty?             [_ _ _] {:spec empty?})\n(defmethod parse-form 'clojure.core/associative?       [_ _ _] {:spec associative?, :type nil})\n(defmethod parse-form 'clojure.core/sequential?        [_ _ _] {:spec sequential?})\n#?(:clj (defmethod parse-form 'clojure.core/ratio?     [_ _ _] {:spec ratio?, :type :ratio}))\n#?(:clj (defmethod parse-form 'clojure.core/bytes?     [_ _ _] {:spec bytes?}))\n\n(defmethod parse-form :clojure.spec.alpha/unknown [_ _ _])\n\n(defmethod parse-form 'clojure.spec.alpha/keys [_ form _]\n  (let [{:keys [req opt req-un opt-un key->spec]} (impl/parse-keys form)]\n    (cond-> {:type :map\n             ::key->spec key->spec\n             ::keys (set (concat req opt req-un opt-un))}\n            (or req req-un) (assoc ::keys-req (set (concat req req-un)))\n            (or opt opt-un) (assoc ::keys-opt (set (concat opt opt-un))))))\n\n#?(:clj\n   (defn get-multi-spec-sub-specs\n     \"Given a multi-spec form, call its multi method methods to retrieve\n   its subspecs.\"\n     [multi-spec-form]\n     (let [[_ multi-method-symbol & _] multi-spec-form]\n       (->> (resolve multi-method-symbol)\n            deref\n            methods\n            (map (fn [[spec-k method]]\n                   [spec-k (method nil)])))))\n   :cljs\n   (defn get-multi-spec-sub-specs\n     \"Given a multi-spec form, call its multi method methods to retrieve\n   its subspecs.\"\n     [multi-spec-form]\n     (let [[_ multi-method-symbol & _ :as form] multi-spec-form]\n       (when-let [spec (first (filter (fn [v] (= form (s/form v))) (vals (s/registry))))]\n         (->> (.-mmvar spec)\n              deref\n              methods\n              (map (fn [[spec-k method]]\n                     [spec-k (method nil)])))))))\n\n(defmethod parse-form 'clojure.spec.alpha/multi-spec [_ form _]\n  {:type :multi-spec\n   ::key (last form)\n   ::dispatch (into {} (get-multi-spec-sub-specs form))})\n\n(defmethod parse-form 'clojure.spec.alpha/or [_ form options]\n  (let [specs (mapv (comp #(parse-spec-with-spec-ref % options) second) (partition 2 (rest form)))]\n    {:type [:or (->> specs (map :type) (distinct) (keep identity) (vec))]\n     ::items specs}))\n\n(defmethod parse-form 'clojure.spec.alpha/and [_ form options]\n  (let [specs (mapv #(parse-spec-with-spec-ref % options) (rest form))\n        types (->> specs (map :type) (distinct) (keep identity) (vec))]\n    {:type [:and types]\n     ::items specs}))\n\n(defmethod parse-form 'clojure.spec.alpha/merge [_ form options]\n  (let [type-priority #(if (= (:type %) :multi-spec) 1 0)]\n    (apply impl/deep-merge (->> (rest form)\n                                (map #(parse-spec % options))\n                                (sort-by type-priority)))))\n\n(defmethod parse-form 'clojure.spec.alpha/every [_ form options]\n  (let [{:keys [into]} (apply hash-map (drop 2 form))]\n    {::item (parse-spec (second form) options)\n     :type\n     (cond\n       (map? into) :map-of\n       (set? into) :set\n       :else :vector)}))\n\n; every-ks\n\n(defmethod parse-form 'clojure.spec.alpha/coll-of [_ form options]\n  (let [{:keys [into]} (apply hash-map (drop 2 form))]\n    {::item (parse-spec-with-spec-ref (second form) options)\n     :type\n     (cond\n       (map? into) :map-of\n       (set? into) :set\n       :else :vector)}))\n\n(defmethod parse-form 'clojure.spec.alpha/map-of [_ [_ k v] options]\n  {:type :map-of\n   ::key (parse-spec-with-spec-ref k options)\n   ::value (parse-spec-with-spec-ref v options)})\n\n(defmethod parse-form 'spec-tools.core/spec [_ form options]\n  (let [parsed (-> form last :spec (parse-spec options))]\n    (if (:type parsed) parsed {:type :spec})))\n\n; *\n; +\n; ?\n; alt\n; cat\n; &\n; keys*\n\n(defmethod parse-form 'clojure.spec.alpha/tuple [_ [_ & values] options]\n  (let [specs (mapv #(parse-spec-with-spec-ref % options) values)\n        types (mapv :type specs)]\n    {:type [:tuple types]\n     ::items specs}))\n\n(defmethod parse-form 'clojure.spec.alpha/nilable [_ form options]\n  (let [spec (-> form second (parse-spec-with-spec-ref options))]\n    {:type :nilable\n     ::item spec}))\n\n(defmethod parse-form 'spec-tools.core/merge [_ form options]\n  (let [type-priority #((:type %) {:map 1\n                                   :multi-spec 0})]\n    (apply impl/deep-merge (->> (rest form)\n                                (map #(parse-spec % options))\n                                (sort-by type-priority)))))\n"]}