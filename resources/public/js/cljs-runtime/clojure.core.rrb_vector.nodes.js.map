{"version":3,"sources":["clojure/core/rrb_vector/nodes.cljs"],"mappings":"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","names":["clojure.core.rrb-vector.nodes/empty-node","cljs.core/PersistentVector","clojure.core.rrb-vector.nodes/clone","shift","node","cljs.core/VectorNode","cljs.core/aclone","clojure.core.rrb-vector.nodes/regular?","clojure.core.rrb-vector.nodes/node-ranges","clojure.core.rrb-vector.nodes/last-range","rngs","i","clojure.core.rrb-vector.nodes/regular-ranges","cnt","step","r","clojure.core.rrb-vector.nodes/overflow?","root","slc","or__4126__auto__","clojure.core.rrb-vector.nodes/index-of-0","arr","l","h","mid","clojure.core.rrb-vector.nodes/index-of-nil","clojure.core.rrb-vector.nodes/first-child","clojure.core.rrb-vector.nodes/last-child","clojure.core.rrb-vector.nodes/remove-leftmost-child","parent","r?","new-arr","js/Array","cljs.core/array-copy","rng0","new-rngs","lim","cljs.core/->VectorNode","clojure.core.rrb-vector.nodes/replace-leftmost-child","pcnt","child","d","ncnt","li","clojure.core.rrb-vector.nodes/replace-rightmost-child","j","clojure.core.rrb-vector.nodes/new-path*","reg?","len","G__31618","ret","a","e","clojure.core.rrb-vector.nodes/fold-tail","tail","tlen","cret","G__31622","G__31623","G__31624","G__31625","cljs.core/mod"],"sourcesContent":["(ns clojure.core.rrb-vector.nodes\n  (:refer-clojure :exclude [clone]))\n\n;;; node ops\n\n(def empty-node cljs.core.PersistentVector.EMPTY_NODE)\n\n(defn clone [shift node]\n  (VectorNode. (.-edit node) (aclone (.-arr node))))\n\n(defn regular? [node]\n  (not (== (alength (.-arr node)) 33)))\n\n;;; ranges\n\n(defn node-ranges [node]\n  (aget (.-arr node) 32))\n\n(defn last-range [node]\n  (let [rngs (node-ranges node)\n        i    (dec (aget rngs 32))]\n    (aget rngs i)))\n\n(defn regular-ranges [shift cnt]\n  (let [step (bit-shift-left 1 shift)\n        rngs (make-array 33)]\n    (loop [i 0 r step]\n      (if (< r cnt)\n        (do (aset rngs i r)\n            (recur (inc i) (+ r step)))\n        (do (aset rngs i cnt)\n            (aset rngs 32 (inc i))\n            rngs)))))\n\n;;; root overflow\n\n(defn overflow? [root shift cnt]\n  (if (regular? root)\n    (> (bit-shift-right cnt 5)\n       (bit-shift-left 1 shift))\n    (let [rngs (node-ranges root)\n          slc  (aget rngs 32)]\n      (and (== slc 32)\n           (or (== shift 5)\n               (recur (aget (.-arr root) (dec slc))\n                      (- shift 5)\n                      (+ (- (aget rngs 31) (aget rngs 30)) 32)))))))\n\n;;; find nil / 0\n\n(defn index-of-0 [arr]\n  (loop [l 0 h 31]\n    (if (>= l (dec h))\n      (if (zero? (int (aget arr l)))\n        l\n        (if (zero? (int (aget arr h)))\n          h\n          32))\n      (let [mid (+ l (bit-shift-right (- h l) 1))]\n        (if (zero? (int (aget arr mid)))\n          (recur l mid)\n          (recur (inc mid) h))))))\n\n(defn index-of-nil ^long [arr]\n  (loop [l 0 h 31]\n    (if (>= l (dec h))\n      (if (nil? (aget arr l))\n        l\n        (if (nil? (aget arr h))\n          h\n          32))\n      (let [mid (+ l (bit-shift-right (- h l) 1))]\n        (if (nil? (aget arr mid))\n          (recur l mid)\n          (recur (inc mid) h))))))\n\n;;; children\n\n(defn first-child [node]\n  (aget (.-arr node) 0))\n\n(defn last-child [node]\n  (let [arr (.-arr node)]\n    (if (regular? node)\n      (aget arr (dec (index-of-nil arr)))\n      (aget arr (dec (aget (node-ranges node) 32))))))\n\n(defn remove-leftmost-child [shift parent]\n  (let [arr (.-arr parent)]\n    (if (nil? (aget arr 1))\n      nil\n      (let [r?      (regular? parent)\n            new-arr (make-array (if r? 32 33))]\n        (array-copy arr 1 new-arr 0 31)\n        (if-not r?\n          (let [rngs     (node-ranges parent)\n                rng0     (aget rngs 0)\n                new-rngs (make-array 33)\n                lim      (aget rngs 32)]\n            (array-copy rngs 1 new-rngs 0 (dec lim))\n            (loop [i 0]\n              (when (< i lim)\n                (aset new-rngs i (- (aget new-rngs i) rng0))\n                (recur (inc i))))\n            (aset new-rngs 32 (dec (aget rngs 32)))\n            (aset new-rngs (dec (aget rngs 32)) 0)\n            (aset new-arr 32 new-rngs)))\n        (->VectorNode (.-edit parent) new-arr)))))\n\n(defn replace-leftmost-child [shift parent pcnt child d]\n  (if (regular? parent)\n    (let [step (bit-shift-left 1 shift)\n          rng0 (- step d)\n          ncnt (- pcnt d)\n          li   (bit-and (bit-shift-right shift (dec pcnt)) 0x1f)\n          arr      (.-arr parent)\n          new-arr  (make-array 33)\n          new-rngs (make-array 33)]\n      (aset new-arr 0 child)\n      (array-copy arr 1 new-arr 1 li)\n      (aset new-arr 32 new-rngs)\n      (aset new-rngs 0 rng0)\n      (aset new-rngs li ncnt)\n      (aset new-rngs 32 (inc li))\n      (loop [i 1]\n        (when (<= i li)\n          (aset new-rngs i (+ (aget new-rngs (dec i)) step))\n          (recur (inc i))))\n      (->VectorNode nil new-arr))\n    (let [new-arr  (aclone (.-arr parent))\n          rngs     (node-ranges parent)\n          new-rngs (make-array 33)\n          li       (dec (aget rngs 32))]\n      (aset new-rngs 32 (aget rngs 32))\n      (aset new-arr 32 new-rngs)\n      (aset new-arr 0 child)\n      (loop [i 0]\n        (when (<= i li)\n          (aset new-rngs i (- (aget rngs i) d))\n          (recur (inc i))))\n      (->VectorNode nil new-arr))))\n\n(defn replace-rightmost-child [shift parent child d]\n  (if (regular? parent)\n    (let [arr (.-arr parent)\n          i   (dec (index-of-nil arr))]\n      (if (regular? child)\n        (let [new-arr (aclone arr)]\n          (aset new-arr i child)\n          (->VectorNode nil new-arr))\n        (let [arr     (.-arr parent)\n              new-arr (make-array 33)\n              step    (bit-shift-left 1 shift)\n              rngs    (make-array 33)]\n          (aset rngs 32 (inc i))\n          (aset new-arr 32 rngs)\n          (array-copy arr 0 new-arr 0 i)\n          (aset new-arr i child)\n          (loop [j 0 r step]\n            (when (<= j i)\n              (aset rngs j r)\n              (recur (inc j) (+ r step))))\n          (aset rngs i (last-range child))\n          (->VectorNode nil new-arr))))\n    (let [rngs     (node-ranges parent)\n          new-rngs (aclone rngs)\n          i        (dec (aget rngs 32))\n          new-arr  (aclone (.-arr parent))]\n      (aset new-arr i child)\n      (aset new-arr 32 new-rngs)\n      (aset new-rngs i (+ (aget rngs i) d))\n      (->VectorNode nil new-arr))))\n\n;;; fold-tail\n\n(defn new-path* [shift node]\n  (let [reg? (== 32 (alength (.-arr node)))\n        len  (if reg? 32 33)\n        arr  (make-array len)\n        rngs (if-not reg?\n               (doto (make-array 33)\n                 (aset 0 (alength (.-arr node)))\n                 (aset 32 1)))\n        ret  (->VectorNode nil arr)]\n    (loop [arr arr shift shift]\n      (if (== shift 5)\n        (do (if-not reg?\n              (aset arr 32 rngs))\n            (aset arr 0 node))\n        (let [a (make-array len)\n              e (->VectorNode nil a)]\n          (aset arr 0 e)\n          (if-not reg?\n            (aset arr 32 rngs))\n          (recur a (- shift 5)))))\n    ret))\n\n(defn fold-tail [node shift cnt tail]\n  (let [tlen     (alength tail)\n        reg?     (and (regular? node) (== tlen 32))\n        arr      (.-arr node)\n        li       (index-of-nil arr)\n        new-arr  (make-array (if reg? 32 33))\n        rngs     (if-not (regular? node) (node-ranges node))\n        cret     (if (== shift 5)\n                   (->VectorNode nil tail)\n                   (fold-tail (aget arr (dec li))\n                              (- shift 5)\n                              (if (regular? node)\n                                (mod cnt (bit-shift-left 1 shift))\n                                (let [li (dec (aget rngs 32))]\n                                  (if (pos? li)\n                                    (- (aget rngs li) (aget rngs (dec li)))\n                                    (aget rngs 0))))\n                              tail))\n        new-rngs (if-not reg?\n                   (if rngs\n                     (aclone rngs)\n                     (regular-ranges shift cnt)))]\n    (when-not (and (or (nil? cret) (== shift 5)) (== li 32))\n      (array-copy arr 0 new-arr 0 li)\n      (when-not reg?\n        (if (or (nil? cret) (== shift 5))\n          (do (aset new-rngs li\n                    (+ (if (pos? li)\n                         (aget new-rngs (dec li))\n                         (int 0))\n                       tlen))\n              (aset new-rngs 32 (inc li)))\n          (do (when (pos? li)\n                (aset new-rngs (dec li)\n                      (+ (aget new-rngs (dec li)) tlen)))\n              (aset new-rngs 32 li))))\n      (if-not reg?\n        (aset new-arr 32 new-rngs))\n      (if (nil? cret)\n        (aset new-arr li (new-path* (- shift 5) (->VectorNode nil tail)))\n        (aset new-arr (if (== shift 5) li (dec li)) cret))\n      (->VectorNode nil new-arr))))\n"]}