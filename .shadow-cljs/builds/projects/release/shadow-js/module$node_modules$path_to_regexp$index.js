["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/path-to-regexp/index.js"],"~:js","shadow$provide[36]=function(J,D,P,l){function H(G,N){var Q=[],M=0,Y=0,X=\"\";N=N&&N.delimiter||\"/\";for(var E;null!=(E=da.exec(G));){var f=E[0],v=E[1],d=E.index;X+=G.slice(Y,d);Y=d+f.length;if(v)X+=v[1];else{var b=G[Y];f=E[2];v=E[3];var c=E[4],h=E[5],a=E[6];d=E[7];X&&(Q.push(X),X=\"\");b=null!=f&&null!=b&&b!==f;var k=\"+\"===a||\"*\"===a;a=\"?\"===a||\"*\"===a;E=E[2]||N;c=c||h;Q.push({name:v||M++,prefix:f||\"\",delimiter:E,optional:a,repeat:k,partial:b,asterisk:!!d,pattern:c?c.replace(/([=!:$\\/()])/g,\"\\\\$1\"):d?\n\".*\":\"[^\"+C(E)+\"]+?\"})}}Y<G.length&&(X+=G.substr(Y));X&&Q.push(X);return Q}function p(G){return encodeURI(G).replace(/[\\/?#]/g,function(N){return\"%\"+N.charCodeAt(0).toString(16).toUpperCase()})}function x(G){return encodeURI(G).replace(/[?#]/g,function(N){return\"%\"+N.charCodeAt(0).toString(16).toUpperCase()})}function K(G,N){for(var Q=Array(G.length),M=0;M<G.length;M++)\"object\"===typeof G[M]&&(Q[M]=new RegExp(\"^(?:\"+G[M].pattern+\")$\",N&&N.sensitive?\"\":\"i\"));return function(Y,X){var E=\"\";Y=Y||{};X=\n(X||{}).pretty?p:encodeURIComponent;for(var f=0;f<G.length;f++){var v=G[f];if(\"string\"===typeof v)E+=v;else{var d=Y[v.name];if(null==d)if(v.optional){v.partial&&(E+=v.prefix);continue}else throw new TypeError('Expected \"'+v.name+'\" to be defined');if(ca(d)){if(!v.repeat)throw new TypeError('Expected \"'+v.name+'\" to not repeat, but received `'+JSON.stringify(d)+\"`\");if(0===d.length)if(v.optional)continue;else throw new TypeError('Expected \"'+v.name+'\" to not be empty');for(var b=0;b<d.length;b++){var c=\nX(d[b]);if(!Q[f].test(c))throw new TypeError('Expected all \"'+v.name+'\" to match \"'+v.pattern+'\", but received `'+JSON.stringify(c)+\"`\");E+=(0===b?v.prefix:v.delimiter)+c}}else{c=v.asterisk?x(d):X(d);if(!Q[f].test(c))throw new TypeError('Expected \"'+v.name+'\" to match \"'+v.pattern+'\", but received \"'+c+'\"');E+=v.prefix+c}}}return E}}function C(G){return G.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g,\"\\\\$1\")}function L(G,N){G.keys=N;return G}function U(G,N,Q){ca(N)||(Q=N||Q,N=[]);Q=Q||{};for(var M=Q.strict,\nY=!1!==Q.end,X=\"\",E=0;E<G.length;E++){var f=G[E];if(\"string\"===typeof f)X+=C(f);else{var v=C(f.prefix),d=\"(?:\"+f.pattern+\")\";N.push(f);f.repeat&&(d+=\"(?:\"+v+d+\")*\");d=f.optional?f.partial?v+\"(\"+d+\")?\":\"(?:\"+v+\"(\"+d+\"))?\":v+\"(\"+d+\")\";X+=d}}G=C(Q.delimiter||\"/\");E=X.slice(-G.length)===G;M||(X=(E?X.slice(0,-G.length):X)+\"(?:\"+G+\"(?\\x3d$))?\");return L(new RegExp(\"^\"+(Y?X+\"$\":X+(M&&E?\"\":\"(?\\x3d\"+G+\"|$)\")),Q&&Q.sensitive?\"\":\"i\"),N)}function fa(G,N,Q){ca(N)||(Q=N||Q,N=[]);Q=Q||{};if(G instanceof RegExp){if(Q=\nG.source.match(/\\((?!\\?)/g))for(var M=0;M<Q.length;M++)N.push({name:M,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return L(G,N)}if(ca(G)){M=[];for(var Y=0;Y<G.length;Y++)M.push(fa(G[Y],N,Q).source);G=new RegExp(\"(?:\"+M.join(\"|\")+\")\",Q&&Q.sensitive?\"\":\"i\");return L(G,N)}return U(H(G,Q),N,Q)}var ca=D(35);P.exports=fa;P.exports.parse=H;P.exports.compile=function(G,N){return K(H(G,N),N)};P.exports.tokensToFunction=K;P.exports.tokensToRegExp=U;var da=/(\\\\.)|([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))/g}","~:source","shadow$provide[36] = function(global,require,module,exports) {\nvar isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$isarray$index"]],"~:properties",["^5",["partial","keys","optional","prefix","repeat","name","asterisk","delimiter","compile","pattern","tokensToRegExp","parse","tokensToFunction"]],"~:compiled-at",1623701842804,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$path_to_regexp$index.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/path-to-regexp/index.js\"],\n\"sourcesContent\":[\"shadow$provide[36] = function(global,require,module,exports) {\\nvar isarray = require('isarray')\\n\\n/**\\n * Expose `pathToRegexp`.\\n */\\nmodule.exports = pathToRegexp\\nmodule.exports.parse = parse\\nmodule.exports.compile = compile\\nmodule.exports.tokensToFunction = tokensToFunction\\nmodule.exports.tokensToRegExp = tokensToRegExp\\n\\n/**\\n * The main path matching regexp utility.\\n *\\n * @type {RegExp}\\n */\\nvar PATH_REGEXP = new RegExp([\\n  // Match escaped characters that would otherwise appear in future matches.\\n  // This allows the user to escape special characters that won't transform.\\n  '(\\\\\\\\\\\\\\\\.)',\\n  // Match Express-style parameters and un-named parameters with a prefix\\n  // and optional suffixes. Matches appear as:\\n  //\\n  // \\\"/:test(\\\\\\\\d+)?\\\" => [\\\"/\\\", \\\"test\\\", \\\"\\\\d+\\\", undefined, \\\"?\\\", undefined]\\n  // \\\"/route(\\\\\\\\d+)\\\"  => [undefined, undefined, undefined, \\\"\\\\d+\\\", undefined, undefined]\\n  // \\\"/*\\\"            => [\\\"/\\\", undefined, undefined, undefined, undefined, \\\"*\\\"]\\n  '([\\\\\\\\/.])?(?:(?:\\\\\\\\:(\\\\\\\\w+)(?:\\\\\\\\(((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()])+)\\\\\\\\))?|\\\\\\\\(((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()])+)\\\\\\\\))([+*?])?|(\\\\\\\\*))'\\n].join('|'), 'g')\\n\\n/**\\n * Parse a string for the raw tokens.\\n *\\n * @param  {string}  str\\n * @param  {Object=} options\\n * @return {!Array}\\n */\\nfunction parse (str, options) {\\n  var tokens = []\\n  var key = 0\\n  var index = 0\\n  var path = ''\\n  var defaultDelimiter = options && options.delimiter || '/'\\n  var res\\n\\n  while ((res = PATH_REGEXP.exec(str)) != null) {\\n    var m = res[0]\\n    var escaped = res[1]\\n    var offset = res.index\\n    path += str.slice(index, offset)\\n    index = offset + m.length\\n\\n    // Ignore already escaped sequences.\\n    if (escaped) {\\n      path += escaped[1]\\n      continue\\n    }\\n\\n    var next = str[index]\\n    var prefix = res[2]\\n    var name = res[3]\\n    var capture = res[4]\\n    var group = res[5]\\n    var modifier = res[6]\\n    var asterisk = res[7]\\n\\n    // Push the current path onto the tokens.\\n    if (path) {\\n      tokens.push(path)\\n      path = ''\\n    }\\n\\n    var partial = prefix != null && next != null && next !== prefix\\n    var repeat = modifier === '+' || modifier === '*'\\n    var optional = modifier === '?' || modifier === '*'\\n    var delimiter = res[2] || defaultDelimiter\\n    var pattern = capture || group\\n\\n    tokens.push({\\n      name: name || key++,\\n      prefix: prefix || '',\\n      delimiter: delimiter,\\n      optional: optional,\\n      repeat: repeat,\\n      partial: partial,\\n      asterisk: !!asterisk,\\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\\n    })\\n  }\\n\\n  // Match any characters still remaining.\\n  if (index < str.length) {\\n    path += str.substr(index)\\n  }\\n\\n  // If the path exists, push it onto the end.\\n  if (path) {\\n    tokens.push(path)\\n  }\\n\\n  return tokens\\n}\\n\\n/**\\n * Compile a string to a template function for the path.\\n *\\n * @param  {string}             str\\n * @param  {Object=}            options\\n * @return {!function(Object=, Object=)}\\n */\\nfunction compile (str, options) {\\n  return tokensToFunction(parse(str, options), options)\\n}\\n\\n/**\\n * Prettier encoding of URI path segments.\\n *\\n * @param  {string}\\n * @return {string}\\n */\\nfunction encodeURIComponentPretty (str) {\\n  return encodeURI(str).replace(/[\\\\/?#]/g, function (c) {\\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\\n  })\\n}\\n\\n/**\\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\\n *\\n * @param  {string}\\n * @return {string}\\n */\\nfunction encodeAsterisk (str) {\\n  return encodeURI(str).replace(/[?#]/g, function (c) {\\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\\n  })\\n}\\n\\n/**\\n * Expose a method for transforming tokens into the path function.\\n */\\nfunction tokensToFunction (tokens, options) {\\n  // Compile all the tokens into regexps.\\n  var matches = new Array(tokens.length)\\n\\n  // Compile all the patterns before compilation.\\n  for (var i = 0; i < tokens.length; i++) {\\n    if (typeof tokens[i] === 'object') {\\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\\n    }\\n  }\\n\\n  return function (obj, opts) {\\n    var path = ''\\n    var data = obj || {}\\n    var options = opts || {}\\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\\n\\n    for (var i = 0; i < tokens.length; i++) {\\n      var token = tokens[i]\\n\\n      if (typeof token === 'string') {\\n        path += token\\n\\n        continue\\n      }\\n\\n      var value = data[token.name]\\n      var segment\\n\\n      if (value == null) {\\n        if (token.optional) {\\n          // Prepend partial segment prefixes.\\n          if (token.partial) {\\n            path += token.prefix\\n          }\\n\\n          continue\\n        } else {\\n          throw new TypeError('Expected \\\"' + token.name + '\\\" to be defined')\\n        }\\n      }\\n\\n      if (isarray(value)) {\\n        if (!token.repeat) {\\n          throw new TypeError('Expected \\\"' + token.name + '\\\" to not repeat, but received `' + JSON.stringify(value) + '`')\\n        }\\n\\n        if (value.length === 0) {\\n          if (token.optional) {\\n            continue\\n          } else {\\n            throw new TypeError('Expected \\\"' + token.name + '\\\" to not be empty')\\n          }\\n        }\\n\\n        for (var j = 0; j < value.length; j++) {\\n          segment = encode(value[j])\\n\\n          if (!matches[i].test(segment)) {\\n            throw new TypeError('Expected all \\\"' + token.name + '\\\" to match \\\"' + token.pattern + '\\\", but received `' + JSON.stringify(segment) + '`')\\n          }\\n\\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\\n        }\\n\\n        continue\\n      }\\n\\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\\n\\n      if (!matches[i].test(segment)) {\\n        throw new TypeError('Expected \\\"' + token.name + '\\\" to match \\\"' + token.pattern + '\\\", but received \\\"' + segment + '\\\"')\\n      }\\n\\n      path += token.prefix + segment\\n    }\\n\\n    return path\\n  }\\n}\\n\\n/**\\n * Escape a regular expression string.\\n *\\n * @param  {string} str\\n * @return {string}\\n */\\nfunction escapeString (str) {\\n  return str.replace(/([.+*?=^!:${}()[\\\\]|\\\\/\\\\\\\\])/g, '\\\\\\\\$1')\\n}\\n\\n/**\\n * Escape the capturing group by escaping special characters and meaning.\\n *\\n * @param  {string} group\\n * @return {string}\\n */\\nfunction escapeGroup (group) {\\n  return group.replace(/([=!:$\\\\/()])/g, '\\\\\\\\$1')\\n}\\n\\n/**\\n * Attach the keys as a property of the regexp.\\n *\\n * @param  {!RegExp} re\\n * @param  {Array}   keys\\n * @return {!RegExp}\\n */\\nfunction attachKeys (re, keys) {\\n  re.keys = keys\\n  return re\\n}\\n\\n/**\\n * Get the flags for a regexp from the options.\\n *\\n * @param  {Object} options\\n * @return {string}\\n */\\nfunction flags (options) {\\n  return options && options.sensitive ? '' : 'i'\\n}\\n\\n/**\\n * Pull out keys from a regexp.\\n *\\n * @param  {!RegExp} path\\n * @param  {!Array}  keys\\n * @return {!RegExp}\\n */\\nfunction regexpToRegexp (path, keys) {\\n  // Use a negative lookahead to match only capturing groups.\\n  var groups = path.source.match(/\\\\((?!\\\\?)/g)\\n\\n  if (groups) {\\n    for (var i = 0; i < groups.length; i++) {\\n      keys.push({\\n        name: i,\\n        prefix: null,\\n        delimiter: null,\\n        optional: false,\\n        repeat: false,\\n        partial: false,\\n        asterisk: false,\\n        pattern: null\\n      })\\n    }\\n  }\\n\\n  return attachKeys(path, keys)\\n}\\n\\n/**\\n * Transform an array into a regexp.\\n *\\n * @param  {!Array}  path\\n * @param  {Array}   keys\\n * @param  {!Object} options\\n * @return {!RegExp}\\n */\\nfunction arrayToRegexp (path, keys, options) {\\n  var parts = []\\n\\n  for (var i = 0; i < path.length; i++) {\\n    parts.push(pathToRegexp(path[i], keys, options).source)\\n  }\\n\\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\\n\\n  return attachKeys(regexp, keys)\\n}\\n\\n/**\\n * Create a path regexp from string input.\\n *\\n * @param  {string}  path\\n * @param  {!Array}  keys\\n * @param  {!Object} options\\n * @return {!RegExp}\\n */\\nfunction stringToRegexp (path, keys, options) {\\n  return tokensToRegExp(parse(path, options), keys, options)\\n}\\n\\n/**\\n * Expose a function for taking tokens and returning a RegExp.\\n *\\n * @param  {!Array}          tokens\\n * @param  {(Array|Object)=} keys\\n * @param  {Object=}         options\\n * @return {!RegExp}\\n */\\nfunction tokensToRegExp (tokens, keys, options) {\\n  if (!isarray(keys)) {\\n    options = /** @type {!Object} */ (keys || options)\\n    keys = []\\n  }\\n\\n  options = options || {}\\n\\n  var strict = options.strict\\n  var end = options.end !== false\\n  var route = ''\\n\\n  // Iterate over the tokens and create our regexp string.\\n  for (var i = 0; i < tokens.length; i++) {\\n    var token = tokens[i]\\n\\n    if (typeof token === 'string') {\\n      route += escapeString(token)\\n    } else {\\n      var prefix = escapeString(token.prefix)\\n      var capture = '(?:' + token.pattern + ')'\\n\\n      keys.push(token)\\n\\n      if (token.repeat) {\\n        capture += '(?:' + prefix + capture + ')*'\\n      }\\n\\n      if (token.optional) {\\n        if (!token.partial) {\\n          capture = '(?:' + prefix + '(' + capture + '))?'\\n        } else {\\n          capture = prefix + '(' + capture + ')?'\\n        }\\n      } else {\\n        capture = prefix + '(' + capture + ')'\\n      }\\n\\n      route += capture\\n    }\\n  }\\n\\n  var delimiter = escapeString(options.delimiter || '/')\\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\\n\\n  // In non-strict mode we allow a slash at the end of match. If the path to\\n  // match already ends with a slash, we remove it for consistency. The slash\\n  // is valid at the end of a path match, not in the middle. This is important\\n  // in non-ending mode, where \\\"/test/\\\" shouldn't match \\\"/test//route\\\".\\n  if (!strict) {\\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\\n  }\\n\\n  if (end) {\\n    route += '$'\\n  } else {\\n    // In non-ending mode, we need the capturing groups to match as much as\\n    // possible by using a positive lookahead to the end or next path segment.\\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\\n  }\\n\\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\\n}\\n\\n/**\\n * Normalize the given path string, returning a regular expression.\\n *\\n * An empty array can be passed in for the keys, which will hold the\\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\\n *\\n * @param  {(string|RegExp|Array)} path\\n * @param  {(Array|Object)=}       keys\\n * @param  {Object=}               options\\n * @return {!RegExp}\\n */\\nfunction pathToRegexp (path, keys, options) {\\n  if (!isarray(keys)) {\\n    options = /** @type {!Object} */ (keys || options)\\n    keys = []\\n  }\\n\\n  options = options || {}\\n\\n  if (path instanceof RegExp) {\\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\\n  }\\n\\n  if (isarray(path)) {\\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\\n  }\\n\\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parse\",\"str\",\"options\",\"tokens\",\"key\",\"index\",\"path\",\"defaultDelimiter\",\"delimiter\",\"res\",\"PATH_REGEXP\",\"exec\",\"m\",\"escaped\",\"offset\",\"slice\",\"length\",\"next\",\"prefix\",\"name\",\"capture\",\"group\",\"modifier\",\"asterisk\",\"push\",\"partial\",\"repeat\",\"optional\",\"pattern\",\"replace\",\"escapeString\",\"substr\",\"encodeURIComponentPretty\",\"encodeURI\",\"c\",\"charCodeAt\",\"toString\",\"toUpperCase\",\"encodeAsterisk\",\"tokensToFunction\",\"matches\",\"Array\",\"i\",\"RegExp\",\"sensitive\",\"obj\",\"opts\",\"data\",\"encode\",\"pretty\",\"encodeURIComponent\",\"token\",\"value\",\"TypeError\",\"isarray\",\"JSON\",\"stringify\",\"j\",\"segment\",\"test\",\"attachKeys\",\"re\",\"keys\",\"tokensToRegExp\",\"strict\",\"end\",\"route\",\"endsWithDelimiter\",\"pathToRegexp\",\"groups\",\"source\",\"match\",\"parts\",\"regexp\",\"join\",\"compile\"]\n}\n"]